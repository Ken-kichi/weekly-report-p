0:00:00.000,0:00:06.000
生成AIで週報を書いてもレビューで手直しになる、その課題をLangGraphで解決します。

0:00:06.000,0:00:12.000
状態管理と再生成ループをコードで表現して、80点を超えるまで自動で改善させます。

0:00:12.000,0:00:18.000
この動画は実装しながら進めるので、IDEを開いて一緒に写経していきましょう。

0:00:18.000,0:00:30.000
ショートでも伝わるよう、ノード図とスコアログのモンタージュでLangGraphの雰囲気を掴んでください。

0:00:30.000,0:01:00.000
これから20分、状態・分岐・ループをすべてLangGraphで描ききるのがゴールです。

0:01:00.000,0:01:30.000
第1章ではまず否定から入ります。週報を一度生成するだけならLangGraphは不要です。

0:01:30.000,0:02:00.000
単発プロンプトでも下書きは作れるので、わざわざState設計を持ち込む必要はありません。

0:02:00.000,0:02:30.000
しかし実務では必ず生成→評価→修正のループが発生し、ifやwhileだけでは状態が追えなくなります。

0:02:30.000,0:03:00.000
何回目の生成か、直前のスコアは何点か、こうした情報をStateとして持ちたいという問題意識を共有します。

0:03:00.000,0:03:30.000
LangGraphは賢いif文ではなく、状態遷移をそのままコードに落とす設計ツールだと位置付けます。

0:03:30.000,0:04:00.000
第2章では全体アーキテクチャを掴みます。article.mdのフロー図を表示しながら6ステップを確認。

0:04:00.000,0:04:30.000
処理はgit log取得、下書き生成、複数評価、スコア判定、再生成、Markdown保存の順です。

0:04:30.000,0:05:00.000
VS Code端末に切り替え、`uv init`から仮想環境・依存ライブラリまで一気にセットアップします。

0:05:00.000,0:06:00.000
`touch cli.py …` で各責務のファイルを作成し、reportディレクトリを出力先として確保します。

0:06:00.000,0:06:30.000
第3章に入り、CLI UXを実装。Typerで`generate`と`evaluate`の2コマンドだけを定義します。

0:06:30.000,0:07:00.000
CLIは入口なのでロジックは持たせません。`uv run main.py generate`ですべてが走る設計を強調。

0:07:00.000,0:07:30.000
`--since`, `--repo`, `--max-iteration` のオプションをコードで入力し、ログ体験の重要性を説明します。

0:07:30.000,0:08:30.000
CLIは「今どの段階か」「なぜ再生成するのか」を常に出力し、LangGraphを感じさせる役割を担います。

0:08:30.000,0:09:00.000
第4章のState設計へ。`ReviewResult`や`GitDiffEntry`のTypedDictを入力して土台を作ります。

0:09:00.000,0:09:30.000
`WeeklyReportState`にgit_diffs、report_draft、reviews、iterationなどを定義しながらコメントで役割を説明。

0:09:30.000,0:10:30.000
Stateは業務フローの写し鏡であり、ここを曖昧にするとLangGraph全体が破綻することを強調します。

0:10:30.000,0:11:00.000
iterationとmax_iterationで評価ループを制御し、average_scoreで合否を決めるという設計を共有。

0:11:00.000,0:11:30.000
第5章では生成エージェントを実装。`generator.py`に`ChatOpenAI`を読み込み、dotenvでキーを扱います。

0:11:30.000,0:12:00.000
`_build_prompt`で初回と再生成のプロンプトを分岐し、初回は網羅性、再生成は指摘反映へフォーカス。

0:12:00.000,0:12:30.000
`generate_weekly_report`と`regenerate_weekly_report`でログを出しつつiterationをインクリメント。

0:12:30.000,0:13:30.000
LLMのレスポンスをStateに書き込み、どのループでも最新版の`report_draft`だけを見る設計にします。

0:13:30.000,0:14:30.000
第6章は評価ノード。`evaluator.py`で数値スコアを強制し、コメントだけでは制御できない理由を解説。

0:14:30.000,0:15:00.000
`Score: <0-100>`形式を正規表現で抽出し、0〜100にクリップしてStateに保存します。

0:15:00.000,0:16:00.000
`evaluate_report_file`で既存Markdownを再評価する関数も実装し、CLIの`evaluate`コマンドと接続。

0:16:00.000,0:17:00.000
評価は制御信号であり、80点未満はREJECTするという明確なルールをここで宣言します。

0:17:00.000,0:17:30.000
第7章では複数評価者を導入。`multi_evaluator.py`にtech、manager、writerの3ロールを定義。

0:17:30.000,0:18:00.000
各ロールは独立して`ChatOpenAI`を呼び、重み付きスコアとフィードバックを返します。

0:18:00.000,0:18:30.000
`state["reviews"]`にはロールごとの全文コメントを追加し、`average_score`は重み付き平均で算出。

0:18:30.000,0:19:30.000
CLIログに `[Review:tech] Score: 72` のような行を出し、利用者が視点ごとの差を把握できるようにします。

0:19:30.000,0:20:00.000
スコア80以上でACCEPT、iteration上限でSTOP、それ以外はREJECTという分岐を口頭で整理。

0:20:00.000,0:20:30.000
第8章のLangGraph構築へ。`build_graph.py`でStateGraphを初期化し、各ノードを登録します。

0:20:30.000,0:21:00.000
`should_continue`関数で`approve` `stop` `regenerate`を返し、conditional edgeで分岐を記述。

0:21:00.000,0:21:30.000
`graph.add_edge("regenerate","evaluate")`でループを閉じ、設計図どおりの流れをコード化。

0:21:30.000,0:22:00.000
`_save_report`で`report/weekly-report-YYYY_MM_DD_hh-mm.md`にMarkdownを保存し、Log上でパスを案内。

0:22:00.000,0:23:00.000
`run_graph`で初期Stateを用意し、CLIから引数を渡して`graph.invoke`する流れを実装。

0:23:00.000,0:23:30.000
第9章はmain.pyと実行デモ。`main.py`でCLI runを呼び出し、すぐにターミナルデモに移ります。

0:23:30.000,0:24:00.000
`uv run main.py generate --since "last monday"`を実行し、ログが流れる様子をノーカットで見せます。

0:24:00.000,0:24:30.000
1回目は70点台でREJECT、2回目で80点台になりACCEPTするシナリオを再現。

0:24:30.000,0:25:00.000
`cat report/weekly-report-****.md`で最終Markdownを表示し、そのまま業務で使える品質を示します。

0:25:00.000,0:25:30.000
第10章では応用アイデア。PR説明、議事録、提案書などStateを差し替えるだけで展開可能と紹介。

0:25:30.000,0:26:00.000
評価軸を設計するのが人間の仕事であり、LangGraphはそれを忠実に回す装置だと締めます。

0:26:00.000,0:26:30.000
次回予告としてSlack通知や部分合格など追加機能を挙げ、概要欄のリポジトリを案内。

0:26:30.000,0:27:00.000
最後にCTA。リポジトリをクローンして自分の評価フローをLangGraphに落とし込み、質問はコメントへどうぞ。
