# オープニング
今回はLangGraphを使って、Gitのログから自動で週報を作成するワークフローを構築します。
CLIでコマンドを打つだけでレポートが完成するので、毎週の報告作業を大幅に短縮できます。
単体のAIに任せると途中の判断が見えにくくなりますが、LangGraphなら各エージェントの状態を追跡でき、条件分岐や繰り返し改善も自在です。
さらに3つの評価AIを導入し、常に80点以上の品質でレポートを仕上げます。
状態が見える化されると、どこで点数が落ちたのかを即座に特定できるので、初心者でも改善サイクルを回しやすくなるのがこの実装方針を選んだ理由です。
コマンドラインでリポジトリを指定すると、ログを要約、評価、改善、最終レポート提示をしてくれます。
それではセットアップへ進みましょう！

# セットアップ
デスクトップに新しいプロジェクトフォルダを作成します。
プロジェクトを初期化し、仮想環境を用意して有効化します。　　　
uvはLangGraphのような依存が多いライブラリでもしっかり管理できます。
実装するファイルを空の状態で作り、エディターを起動します。
依存ライブラリをインストールし、envファイルにはOpenAI APIキーを記入します。
envファイルを追加することで、秘密情報の漏洩を防ぎます。

# CLI UXの実装
次に、コマンドラインから実行するためのCLIを作ります。
ここではTyperを使います。理由は、型ヒントを書くだけで分かりやすいCLIが作れて、初心者でも扱いやすいからです。
このCLIの役割はとてもシンプルで、リポジトリのパスを受け取り、存在をチェックし、LangGraphの処理を呼び出すだけです。
業務ロジックは一切書かず、あくまで入口に徹します。こうしておくと、あとでWebアプリやバッチ処理に流用するのも簡単になります。

# 状態管理の設計
ここからがLangGraphの一番重要な考え方です。
LangGraphでは、処理の途中結果をすべてStateとして共有します。
今回のStateには、Gitログの要約、生成した週報の下書き、各評価AIのスコア、改善指示、そして最終的なレポートをまとめて入れます。
これを一つに集約することで、「今どこで品質が落ちているのか」「何回目の改善ループなのか」といったことが後からすぐに分かります。
単体AIでは見えなかった部分が、LangGraphでははっきり見えるようになります。

# git読み取り処理を実装
次に、Gitのログを読み取る処理を実装します。
指定されたリポジトリに対してgit logを実行し、期間やコミット数を絞って情報をまとめます。
この段階で不要な情報を削っておくことがとても重要です。
ノイズを減らしておくことで、AIの出力が安定し、トークン消費やコストも予測しやすくなります。

# 生成処理の実装
ログの要約ができたら、週報の下書きを生成します。
構成は「今週やったこと」「成果」「課題」「来週の予定」といった形で固定します。
これは、あとで評価をしやすくするためです。
このステップでは、とにかく一次生成に集中させ、改善や判断は次の工程に任せます。

# 評価処理の実装
続いて、評価の処理に入ります。
生成された週報を別のAIに読ませ、「事実として正しいか」「内容に抜け漏れがないか」「読みやすいか」といった観点で点数を付けます。
生成したAIとは別のAIに評価させることで、AIがAIをチェックする構造を作れます。
ここが、単体AIとの大きな違いです。

# 複数評価処理の実装
さらに今回は、評価AIを3つ並列で動かします。
それぞれのスコアを集計し、平均点や最低点を見ます。
もし80点未満であれば、どこが悪かったのかをStateに残し、改善ループに戻します。
LangGraphでは、こうした条件分岐やループを自然な形で表現できます。

# 生成フローを構築
最後に、これまで作った処理をLangGraphのワークフローとしてつなぎます。
ログ取得、生成、評価、改善、終了判定という流れがコードとしてそのまま表現されるため、業務フローを実装している感覚に近くなります。

# 実行エントリ
CLIからコマンドを実行すると、Gitログの読み取りから週報の生成、評価と改善、最終出力までが一気に自動で回ります。
毎週手作業でやっていた報告作業が、そのまま仕組みに置き換わるイメージです。

# エンディング
AIで業務を自動化するには、今回のようにフロー全体を設計しておくことが不可欠です。
フローがあることで業務が可視化され、品質保証や改善ループ、さらにはルーティンワークの自動化まで一気通貫で実現できます。
ぜひ自分の業務を整理するところから始めて、LangGraphでAIエージェントを実装するところまで挑戦してみてください。
